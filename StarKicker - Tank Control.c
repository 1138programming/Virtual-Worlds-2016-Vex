#pragma config(I2C_Usage, I2C1, i2cSensors)
#pragma config(Sensor, in1,    leftLineFollower, sensorLineFollower)
#pragma config(Sensor, in2,    middleLineFollower, sensorLineFollower)
#pragma config(Sensor, in3,    rightLineFollower, sensorLineFollower)
#pragma config(Sensor, dgtl1,  rightEncoder,   sensorQuadEncoder)
#pragma config(Sensor, dgtl3,  leftEncoder,    sensorQuadEncoder)
#pragma config(Sensor, dgtl5,  limitSwitch,    sensorTouch)
#pragma config(Sensor, dgtl9,  sonarSensor,    sensorSONAR_cm)
#pragma config(Sensor, I2C_1,  ,               sensorQuadEncoderOnI2CPort,    , AutoAssign )
#pragma config(Sensor, I2C_2,  ,               sensorQuadEncoderOnI2CPort,    , AutoAssign )
#pragma config(Sensor, I2C_3,  ,               sensorQuadEncoderOnI2CPort,    , AutoAssign )
#pragma config(Sensor, I2C_4,  ,               sensorQuadEncoderOnI2CPort,    , AutoAssign )
#pragma config(Sensor, I2C_5,  ,               sensorQuadEncoderOnI2CPort,    , AutoAssign )
#pragma config(Sensor, I2C_6,  ,               sensorQuadEncoderOnI2CPort,    , AutoAssign )
#pragma config(Sensor, I2C_7,  ,               sensorQuadEncoderOnI2CPort,    , AutoAssign )
#pragma config(Sensor, I2C_8,  ,               sensorQuadEncoderOnI2CPort,    , AutoAssign )
#pragma config(Motor,  port1,           rearRightMotor, tmotorVex393_HBridge, openLoop, reversed, driveRight, encoderPort, I2C_1)
#pragma config(Motor,  port2,           rearLeftMotor, tmotorVex393_MC29, openLoop, driveLeft, encoderPort, I2C_3)
#pragma config(Motor,  port3,           frontRightMotor, tmotorVex393_MC29, openLoop, reversed, driveRight, encoderPort, I2C_2)
#pragma config(Motor,  port4,           frontLeftMotor, tmotorVex393_MC29, openLoop, driveLeft, encoderPort, I2C_4)
#pragma config(Motor,  port5,           leftSlideMotor, tmotorVex393_MC29, openLoop, encoderPort, I2C_6)
#pragma config(Motor,  port6,           rightSlideMotor, tmotorVex393_MC29, openLoop, encoderPort, I2C_7)
#pragma config(Motor,  port7,           kickerArmMotor, tmotorVex393_MC29, openLoop, encoderPort, I2C_5)
#pragma config(Motor,  port8,           kickerMotor,   tmotorVex393_MC29, openLoop, encoderPort, I2C_8)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

/*+++++++++++++++++++++++++++++++++++++++++++++| Notes |++++++++++++++++++++++++++++++++++++++++++++++
VEX Launchbot Arcade Control
- This program allows you to remotely control your robot using the USB Logitech Dual
  Action Joysticks.
- For USB values to be transmitted to the robot, you must follow several steps:
  - Use the "#include "JoystickDriver.c"" line at the beginning of your program
  - Call the "getJoystickSettings(joystick);" in a loop to repeatedly retrieve the latest values
  - Open the Robot > Debugger Windows > "Joystick Control - Basic" window after downloading your
    program to the virtual robot

Robot Model: VEX Launchbot
-This program will allow you to control the VEX Launchbot and its attachments
----------------------------------------------------------------------------------------------------*/

#pragma debuggerWindows("joystickSimple");
#include "JoystickDriver.c"

task main()
{
  //Integer variable that allows you to specify a "deadzone" where values (both positive or negative)
  //less than the threshold will be ignored.
  int threshold = 10;
	int speed = 127;
  //Loop Forever
  while(1 == 1)
  {
    //Get the Latest joystick values
    getJoystickSettings(joystick);

    //DRIVE
    if(abs(joystick.joy1_y2) > threshold)     // If the right analog stick's Y-axis readings are either above or below the threshold...
    {
      motor[rearRightMotor] = joystick.joy1_y2;   // ...the right motor is assigned a power level equal to the right analog stick's Y-axis reading.
      motor[frontRightMotor] = joystick.joy1_y2;
    }
    else                                      // Else the readings are within the threshold, so
    {
      motor[rearRightMotor] = 0;                  // ...the right motor is stopped with a power level of 0.
      motor[frontRightMotor] = 0;
    }


    if(abs(joystick.joy1_y1) > threshold)     // If the left analog stick's Y-axis readings are either above or below the threshold...
    {
      motor[rearLeftMotor] = joystick.joy1_y1;    // ...the left motor is assigned a power level equal to the left analog stick's Y-axis reading.
      motor[frontLeftMotor] = joystick.joy1_y1;
    }
    else                                      // Else if the readings are within the threshold...
    {
      motor[rearLeftMotor] = 0;                   // ...the left motor is stopped with a power level of 0.
      motor[frontLeftMotor] = 0;
    }

    //Kicker ARM MOTOR
    if(joy1Btn(Btn5) == 1)  //If button 5 is pressed...
    {
    	motor[kickerArmMotor] = -63; //... pull the arm
    }
    else if(joy1Btn(Btn7) == 1) //If button 7 is pressed...
    {
    	motor[kickerArmMotor] = 63;  //... kick the arm
    }
    else
    {
    	motor[kickerArmMotor] = 0; //Turn the arm off
    }

    //Kicker Motor
    if(joy1Btn(Btn8) == 1)  //If button 8 is pressed lower the kicker...
    {
    	motor[kickerMotor] = 63; //set kicker to 63
    }
    else if(joy1Btn(Btn6) == 1) //If button 6 is pressed raise the kicker...
    {
    	motor[kickerMotor] = -63; //Set the kicker to -63
    }
    else  //Turn load and kicker motor off
    {
    	motor[kickerMotor] = 0;
    }

    //SLIDE MOTOR
    if(joy1Btn(Btn2) == 1)  //If button 2 is pressed lower the slide...
    {
    	motor[leftSlideMotor] = -127; //...Set the slide motors to -127
    	motor[rightSlideMotor] = -127;
    }
  	else if(joy1Btn(Btn4) == 1) //If button 4 is pressed raise the slide...
    {
    	motor[leftSlideMotor] = 127; //...Set the slide motors to 127
    	motor[rightSlideMotor] = 127;
    }
    else //Stop the slide motors
  	{
  		motor[leftSlideMotor] = 0;
  		motor[rightSlideMotor] = 0;
  	}
	}
}
